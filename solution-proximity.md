### Solution Proximity

This is the notion that the likelihood of finding or pursuing a solution decreases with the distance the solution is from the seeker. It could also be more specfically related to the effort required to find the solution rather than the complexity or difficulty of implementing the solution itself.

In terms of programming languages, a language may be generally used for a specific class of problems that does not contain your problem. Say the language may even present a superior solution to your problem than the languages with a closer solution proximity for you. For instance, the Smalltalk environments are incredible feats of engineering, but I'm much more likely to find solutions to my daily business problems searching for Python implementations than I am Smalltalk implementations. This could even be a totally contrived scenario where Python is both creating and solving the same problem, but I'm still far less likely to move towards the "better" solution if the effort to reach that solution is too great or foreign.

This is very verbose explanation of why people "stick to what they know."

### Knowledge Domains

There must exist domains of knowledge such that domains X and Y have minimal overlapping tools and concepts, and the domains respectively take an entire human lifespan of effort to master. Then it would follow that there's a fundamental necessity for interdisciplinary cooperation as huge swaths of knowledge would be completely inaccessible to an individual. It should also follow that more and more of human knowledge will become inaccessible to individuals due to the limits of the human lifespan in the future.

**Q:** Does there exist a hierachy of programming concepts such that clean abstractions can exist to promote optimal cooperation between domains of knowledge?

Examples of these domains might be: language designers, domain-specific-languages, scripting/interpreted vs compiled languages, dynamic typing vs static styping, parallel algorithms vs linear algorithms, visual object designers vs textual source code, administrators vs developers, subject-matter experts, etc.

These boundaries obviously exist at an informal level, but what should the clean separation between a system administrator and an OS programmer be?

**Q:** How much of a system administrators job is chasing arcane solutions to problems unrelated to any actual first principles?

Is it really a sane workflow to find the correct configuration parameter on the 6th page of a forum discussion of a loosely related problem?

### Self-Describing Systems

A system which, within its own facilities, can guide a user to appropriately use the system and identify all lpossibe interactions with a gradual increase of complexity suitable for taking the user from beginner to master.

"Oh, I didn't know I could interact with that widget..."

"Aha, you have to drag it within this boundary..."

"Well, there's an Excel file in the system folder that describes the hotkeys to interact with the program."

Games are an interesting case study in this regard, in that they have no obvious utility to the real world, yet people spend hundreds of hours carefully tuning the experience so that you're presented with just the right solution proximity such that you can succeed while being adequately challenged at each step.

If a fraction of the effort went into a designing a live programming environment that carefully leads you to the solutions for common business problems, it seems the world would change. Maybe programming problems are just that much more intractable than elaborate game puzzles that require hundreds of hours of refinement of fine motor skills to overcome.

### Reinvention

Inventing grants a unique sense of ownership and understanding. It often seems things are reinvented simply due to the absolute dread imposed by the solution proximity of modifying and understanding a complex system. It seems many would opt to  spend tremendously longer reinventing a solution than opt to understand a complex, existing solution. What is the measure and level of complexity that effectively cripples any efforts to further evolve a system? Abstractions are obviously very important for humans to reason about complex problems.

It seems many good ideas often take quite a long time to percolate through greater society and become generally accepted as truth. Is this a cause of seemingly cyclical emergence of programming concepts that were described some 50 years ago? Or is it just now that the problems have arisen best suited by those old ideas?

