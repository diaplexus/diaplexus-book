### Solution Proximity

This is the notion that the likelihood of finding or pursuing a solution decreases with the distance the solution is from the seeker. It could also be more specfically related to the effort required to find the solution rather than the complexity or difficulty of implementing the solution itself.

In terms of programming languages, a language may be generally used for a specific class of problems that does not contain your problem. Say the language may even present a superior solution to your problem than the languages with a closer solution proximity for you. For instance, the Smalltalk environments are incredible feats of engineering, but I'm much more likely to find solutions to my daily business problems searching for Python implementations than I am Smalltalk implementations. This could even be a totally contrived scenario where Python is both creating and solving the same problem, but I'm still far less likely to move towards the "better" solution if the effort to reach that solution is too great or foreign.

This is very verbose explanation of why people "stick to what they know."

### Knowledge Domains

There must exist domains of knowledge such that domains X and Y have minimal overlapping tools and concepts, and the domain takes an entire human lifespan of effort to master. Then it would follow that there's a fundamental necessity for interdisciplinary cooperation as huge swaths of knowledge would be completely unaccessible to an individual.

**Q:** Does there exist a hierachy of programming concepts such that clean abstractions can exist to promote optimal cooperation between domains of knowledge?

Examples of these domains might be: language designers, domain-specific-languages, scripting/interpreted vs compiled languages, dynamic typing vs static styping, parallel algorithms vs linear algorithms, visual object designers vs textual source code, administrators vs developers, etc.

These boundaries obviously exist at an informal level, but what should the clean separation between a system administrator and a OS programmer be?

**Q:** How much of a system administrators job is chasing arcane solutions to problems unrelated to any actual first principles?

Is it really a sane workflow to find the correct configuration parameter on the 6th page of a forum discussion on a loosely related problem?

### Self-Describing Systems

A system which, within its own facilities, can guide a user to appropriately use the system and identify all of the interactions that are possible with a gradual increase of complexity suitable for taking the user from beginner to master.

"Oh, I didn't know I could interact with that widget..."

"Aha, you have to drag it within this boundary..."

"Well, there's an Excel file in the system folder that describes the hotkeys to interact with the program."

Games are an interesting case study in this regard in that they have no obvious utility to the real world, yet people spend hundreds of hours carefully tuning the experience so that you're presented with just the right solution proximity such that you can succeed while not being too easy.

If a fraction of the effort went into a designing a live programming environment that careful led you to solutions for common business problems, it seems the world would change. Maybe programming problems are just that much more intractable than elaborate game puzzles that require hundreds of hours of refinement of fine motor skills to overcome.

